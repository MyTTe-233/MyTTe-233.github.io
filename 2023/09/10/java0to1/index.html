

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="随手记1.Java源文件以.java为扩展名，源文件的基本组成是类（class）2.Java应用程序的执行入口为main()方法，格式：public static void main(String[] args)&amp;#123;...&amp;#125;3.严格区分大小写4.一个源文件最多一个public类，且文件名同此类名5.其他类个数不限，可将main方法写在非public类中，然后指定运行非public">
<meta property="og:type" content="article">
<meta property="og:title" content="2023&#x2F;09&#x2F;10：java 0 to 1">
<meta property="og:url" content="http://example.com/2023/09/10/java0to1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="随手记1.Java源文件以.java为扩展名，源文件的基本组成是类（class）2.Java应用程序的执行入口为main()方法，格式：public static void main(String[] args)&amp;#123;...&amp;#125;3.严格区分大小写4.一个源文件最多一个public类，且文件名同此类名5.其他类个数不限，可将main方法写在非public类中，然后指定运行非public">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/09/10/java0to1/diedaiqi.png">
<meta property="og:image" content="http://example.com/2023/09/10/java0to1/vector.png">
<meta property="og:image" content="http://example.com/2023/09/10/java0to1/linklist.png">
<meta property="og:image" content="http://example.com/2023/09/10/java0to1/hashmap.png">
<meta property="og:image" content="http://example.com/2023/09/10/java0to1/linkset1.png">
<meta property="og:image" content="http://example.com/2023/09/10/java0to1/hashmap1.png">
<meta property="og:image" content="http://example.com/2023/09/10/java0to1/hashtable.png">
<meta property="og:image" content="http://example.com/2023/09/10/java0to1/properties.png">
<meta property="og:image" content="http://example.com/2023/09/10/java0to1/littletotal.png">
<meta property="og:image" content="http://example.com/2023/09/10/java0to1/xianchengzhongzhi.png">
<meta property="og:image" content="http://example.com/2023/09/10/java0to1/xianchengchangyongfangfa1.png">
<meta property="og:image" content="http://example.com/2023/09/10/java0to1/xianchengchangyongfangfa2.png">
<meta property="og:image" content="http://example.com/2023/09/10/java0to1/userxiancheng.png">
<meta property="og:image" content="http://example.com/2023/09/10/java0to1/xianchengalive.png">
<meta property="og:image" content="http://example.com/2023/09/10/java0to1/xianchengalive2.png">
<meta property="article:published_time" content="2023-09-10T10:49:14.000Z">
<meta property="article:modified_time" content="2023-09-26T11:18:22.122Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2023/09/10/java0to1/diedaiqi.png">
  
  
  
  <title>2023/09/10：java 0 to 1 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="2023/09/10：java 0 to 1"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-09-10 18:49" pubdate>
          September 10, 2023 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          95 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">2023/09/10：java 0 to 1</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="随手记"><a href="#随手记" class="headerlink" title="随手记"></a>随手记</h2><p>1.Java源文件以<code>.java</code>为扩展名，源文件的基本组成是类（class）<br>2.Java应用程序的执行入口为main()方法，格式：<code>public static void main(String[] args)&#123;...&#125;</code><br>3.严格区分大小写<br>4.一个源文件最多一个public类，且文件名同此类名<br>5.其他类个数不限，可将main方法写在非public类中，然后指定运行非public类，这样入口方法就是非public的main方法，且编译时每个类会生成对应的<code>.class</code>文件<br>6.变量的使用大致同C<br>7.关于+<br>    1.左右两边都是数值型时，做加法运算<br>    2.左右两边有一为字符串，做拼接<br>    3.运算从左到右<br>8.数据类型<br>    1.基本数据类型<br>    byte 1字节 -128 —— 127（二进制）<br>    short 2字节 -(2^15) —— (2^15)-1<br>    int 4字节 -(2^31) —— (2^31)-1 整型常量默认int<br>    long 8字节 -(2^63) —— (2^63)-1 long型常量需在数字后加l或L，如long n = 1L<br>    float 4字节 -3.403E38 —— 3.403E38 float常量需加f或F<br>    double 8字节 -1.798E308 —— 1.798E308 浮点常量默认double<br>    char 2字节 可放汉字，使用单引号，本质为整数，输出unicode（兼容ASCII）对应字符，可直接运算<br>    boolen 1字节 仅可true或false<br>    浮点储存：符号位+指数位+尾数位，尾数可能丢失-&gt;精度损失，运算结果比较应采用<code>Math.abs(a - b)&lt;0.001</code>形式，直接赋值或查询得到可<code>==</code><br>    2.引用类型<br>    类 接口 数组<br>9.数据类型转换<br>    1.自动<br>    精度小转大<br>    char-&gt;int-&gt;long-&gt;float-&gt;double<br>    byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double<br>    多种混合运算时，先将所有数据转换为容量最大类型<br>    (byte,short)与char不可相互转换，但可计算，会转为int<br>    精度大赋给精度小报错<br>    boolen不转换<br>    表达式结果自动提升为操作数最大类型<br>    2.强制<br>    例：<code>(int)1.9</code><br>    注意精度降低和可能的溢出<br>    仅对最近操作数有效<br>    char可保存int常量值不保存变量值<br>10.string<br>    基本转string：基本类型值+””<br>    string转基本类型：基本类型包调用方法，如<code>Long.parseLong(&quot;123&quot;)</code><br>    转换为基本类型时注意是否能转换为有效数据，如hello无法转为整数<br>11.运算符<br>    1.&amp;&amp; 和 &amp; 使用区别<br>    &amp;&amp; 短路与：如果第一个条件为 false，则第二个条件不会判断，最终结果为 false，效率高<br>    &amp; 逻辑与：不管第一个条件是否为 false，第二个条件都要判断，效率低<br>    2.|| 和 | 使用区别<br>    ||短路或：如果第一个条件为 true，则第二个条件不会判断，最终结果为 true，效率高<br>    | 逻辑或：不管第一个条件是否为 true，第二个条件都要判断，效率低<br>    开发中，我们基本使用 |<br>12.复合赋值会进行类型转换<br>13.三元运算符<code>...?表达式1:表达式2</code><br>表达式 1 和表达式 2 要为可以赋给接收变量的类型（或可以自动转换）<br>14.键盘输入<br>    1.导入该类的所在包, java.util. （Scanner类，import java.util.Scanner;）<br>    2.创建对象声明变量（如Scanner myScanner = new Scanner(System.in);）<br>    3.调用，如输入int：<code>int age = myScanner.nextInt();</code><br>15.进制<br>二进制 0B或0b开头 八进制 0开头 十六进制 0x或0X开头<br>16.位运算<br>    1.算术右移 <code>&gt;&gt;</code>：低位溢出,符号位不变,并用符号位补溢出的高位<br>    2.算术左移 <code>&lt;&lt;</code>: 符号位不变,低位补 0<br>    3. <code>&gt;&gt;&gt;</code> 逻辑右移也叫无符号右移,运算规则是: 低位溢出，高位补 0<br>17.数组<br>    1.初始化<br>    定义<br>    <code>数据类型 数组名[] = new 数据类型[大小]</code>可分两行<br>    声明<br>    数据类型 数组名[]; 或 数据类型[] 数组名;<br>    <code>int a[]; 或者 int[] a;</code><br>    注意<br>    数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。<br>    数组创建后，如果没有赋值，有默认值<br>int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000，boolean false，String null<br>    数组属引用类型，数组型数据是对象(object)<br>    2.赋值<br>    数组在默认情况下是引用传递，赋的值是地址<br>    <code>int[] arr1 = &#123;1,2,3&#125;;</code>或<code>int[] arr2 = arr1;</code><br>    3.二维数组<br>    <code>int[][] arr</code><br>    每个元素是一维数组，同C，动态初始化<code>int[][] arr = new int[3][]</code><br>    声明：int[][] y 或者 int[] y[] 或者 int y[][]<br>    二维数组实际上是由多个一维数组组成的，它的各个一维数组的长度可以相同，也可以不相同。比如：map[][] 是一个二维数组，由 map[0] 是一个含有两个元素的一维数组 ，map[1] 是一个含有三个元素的一维数组构成，我们也称为列数不等的二维数组<br>18.类与对象<br>    1.对象的属性默认值，遵守数组规则<br>    2.一个方法最多有一个返回值，返回类型可以为任意类型，包含基本类型或引用类型（数组，对象）<br>    3.引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参<br>    4.可变参数<br>    int… 表示接受的是可变参数，类型是 int ,即可以接收多个 int(0-多)<br>    使用可变参数时，可以当做数组来使用，本质就是数组<br>    可与普通参数一起放在列表里，需保证可变参数在最后，如：public void f2(String str, double… nums)<br>    一个形参列表中只能出现一个可变参数<br>19.作用域<br>    1.全局变量（属性）可不赋值，有默认值，可加修饰符，可被其他类使用（对象调用）<br>    2.局部变量不可加修饰符<br>    3.构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化，类似C++，但构造器的修饰符可以默认，也可以是 public protected private<br>    4.this表示当前对象，会分给每个对象，哪个对象调用，就代表哪个对象；可以用来访问本类的属性、方法、构造器；用于区分当前类的属性和局部变量；访问成员方法的语法：this.方法名(参数列表)，访问构造器语法：this(参数列表); 注意只能在构造器中使用（即只能在构造器中访问另外一个构造器, 必须放在第一条语句）；this 不能在类定义的外部使用，只能在类定义的方法中使用<br>20.IDEA<br>    1.使用 IDEA 创建 Java 项目(project)，IDEA 是以项目的概念，来管理 java 源码<br>    2.Settings-&gt;File Encodings改编码<br>21.包<br>    1.作用：区分相同名字的类，便于管理，控制访问范围<br>    2.本质为创建不同的文件夹来保存文件<br>    3. package com.hspedu  package：关键字，表示打包 com.hspedu表示包名<br>    4.常用包<br>        java.lang.*  lang 包是基本包，默认引入，不需要再引入<br>        java.util.*  util 包，系统提供的工具包, 工具类，使用 Scanner<br>        java.net.*  网络包，网络开发<br>        java.awt.*  是做 java 界面开发，GUI<br>    5.引入包<br>    import java.util.Scanner; 引入Scanner类<br>    import java.util.*; 引入所有类<br>    6.package<br>    package 的作用是声明当前类所在的包，需要放在类(或者文件)的最上面，一个类中最多只有一句 package<br>    import 指令位置放在 package 的下面，在类定义前面,可以有多句且没有顺序要求<br>    7.访问修饰符：控制方法和属性(成员变量)的访问权限（范围）<br>    类似类的对象修饰符，默认级别:没有修饰符号,向同一个包的类公开<br>22.继承<br>    1.语法<br>    class 子类 extends 父类{</p>
<pre><code class="hljs">&#125;
2.父类又叫超类，基类 子类又叫派生类
3.super
super(参数列表)指定使用父类的哪个构造器完成对父类的初始化工作，默认情况下总会去调用父类的无参构造器，在使用时，必须放在构造器第一行（super 只能在构造器中使用）
super.属性名 访问父类属性
super.方法名(参数列表) 访问方法
4.java 所有类都是 Object 类的子类, Object 是所有类的基类
5.父类构造器的调用不限于直接父类
6.子类最多只能继承一个父类(指直接继承)
7.关于查找
    1.看子类是否有该属性
    2.如果子类有这个属性，并且可以访问，则返回信息
    3.如果子类没有这个属性，就看父类有没有这个属性（如果父类有该属性，并且可以访问，就返回信息..）
    4.如果父类没有就按照3的规则，继续找上级父类，直到 Object..
</code></pre>
<p>23.override重写<br>    1.定义<br>    子类有一个方法与父类方法的名称、返回类型、参数一样，就是子类重写父类方法<br>    2.注意<br>    不能缩小访问权限 public&gt;protected&gt;默认&gt;private<br>    子类方法的返回类型和父类一样或为父类的子类<br>    属性不可重写，属性值看编译类型<br>24.多态<br>    1.一个对象的编译类型和运行类型可以不一致<br>    2.编译类型在定义对象时已确定不可改变<br>    3.运行类型可改变<br>    4.编译类型看定义时=左，运行类型=右<br>    如：<br>    <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br>    ...<br>&#125;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    ...<br>&#125;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    ...<br>&#125;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span></span>&#123;<br>    public static void main(<span class="hljs-type">String</span>[] args)&#123;<br>        <span class="hljs-type">Animal</span> animal = <span class="hljs-keyword">new</span> <span class="hljs-type">Dog</span>();<br>        animal  = <span class="hljs-keyword">new</span> <span class="hljs-type">Cat</span>()<br>        <span class="hljs-comment">//合法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>    5.多态向上转型<br>        1.本质：父类引用指向子类对象<br>        2.语法： 父类类型 引用名 = new 子类类型()<br>        3.特点：编译类型看左边，运行类型看右边；可以调用父类中的所有成员（需遵守访问权限）；不能调用子类特有成员；最终效果看子类实现<br>    6.多态向下转型<br>        1.语法： 子类类型 引用名 = (子类类型) 父类引用<br>        2.只能强转父类的引用，不能强转父类对象<br>        3.要求父类的引用必须指向的是当前目标类型的对象<br>        4.向下转型后，可调用子类类型所有成员<br>    7.Java动态绑定机制<br>        1.调用对象方法时，该方法会和该对象的内存地址/运行类型绑定<br>        2.调用对象属性时，无动态绑定机制，哪声明哪使用<br>    8.多态参数 多态数组 …<br>    （先放着 偷懒）<br>25.Object<br>    1.equals方法<br>        只能判断引用类型，默认判断地址是否相等，一般重写<br>    2.hashCode方法<br>        返回该对象哈希码值；哈希值主要根据地址号来的，不能完全将哈希值等价于地址；<br>    3.toString方法<br>        默认返回：全类名+@+哈希值的十六进制；重写需@Override<br>    4.finalize方法<br>        当对象被回收时，系统自动调用该对象的 finalize 方法；当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize 方法；垃圾回收机制的调用，是由系统来决定（即有自己的 GC 算法）, 也可以通过 System.gc() 主动触发垃圾回收机制；重写需@Override<br>26.static<br>    1.类变量<br>        一个类所有对象共享，静态变量也叫类变量、静态属性<br>        访问： 类名.类对象名<br>    2.类方法<br>        使用： 类名.方法名<br>        不允许使用和对象有关关键字，只能访问静态变量方法<br>        无this<br>27.main方法<br>    1.可以直接调用 main 方法所在类的静态方法或静态属性<br>    2.不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员<br>    3.接受String类型数组参数，该数组保存执行java命令时传递给所运行的类的参数<br>    4.必须为 public static<br>28.代码块<br>    1.语法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$[修饰符，要写只能写static]&#123;<br>$    代码<br>$&#125;;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">2.相当于另一种形式构造器，代码块调用的顺序优先于构造器（构造方法），
3.在创建对象实例（new）加载/创建子类对象实例父类加载/使用类的静态成员加载，静态代码块随类的加载执行且仅一次，普通代码块每创建一个对象就执行
4.创建对象时的调用顺序
    静态代码块/静态变量初始化-&gt;普通代码块和普通属性-&gt;构造函数
5.子类对象调用顺序
父类静态代码块/静态属性-&gt;子类静态代码块和静态属性-&gt;父类普通代码块和普通属性-&gt;父类构造函数-&gt;子类普通代码块和普通属性-&gt;子类构造函数
</code></pre>
<p>29.单例<br>    1.含义<br>        保证整个软件系统中对某个类只存在一个对象实例，且该类只提供一个取得对象实例的方法<br>    2.实现<br>        构造器私有（防new）-&gt;类内部创建对象-&gt;向外暴露一个静态公共方法<br>    3.饿汉与懒汉<br>        创建对象时机：饿汉在类加载，懒汉在使用时<br>        线程安全：饿汉无，懒汉有<br>        浪费资源可能：饿汉有，懒汉无<br>30.final<br>    1.修饰类、属性、方法<br>    2.使用情况<br>        不希望类被继承 不希望父类某方法被子类重写 不希望类的某属性被修改 不希望某个局部变量被修改<br>    3.注意<br>        final修饰的属性也叫常量，需赋初值，在定义时或构造器或代码块；若该属性静态，不可在构造器赋值；不能继承但可实例化对象；若类不是final，但有final方法，则该方法不可被继承但可被重写；不能修饰构造器；包装类（如Integer Double Float Boolean等）均为final，String也是<br>31.抽象类<br>    abstract声明<br>32.接口<br>    1.定义<br>        将没有实现的方法封装到一起，要使用时再把方法写出来<br>    2.语法<br>    <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名</span>&#123;<br>    属性<br>    抽象方法<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> 类名 <span class="hljs-keyword"><span class="hljs-keyword">implements</span> </span>接口</span>&#123;<br>    自己属性<br>    自己方法<br>    要实现的抽象方法，要@Override<br>&#125;<br></code></pre></td></tr></table></figure><br>    3.接口属性只能final，访问： 接口名.属性名<br>    4.一个类可有多个接口<br>    5.接口不能继承其他类，但可继承多个接口<br>33.内部类<br>    1.定义：一个类内部又完整嵌套另一个类，可直接访问外部类私有属性<br>    2.语法<br>        <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> <span class="hljs-keyword">Outer</span>&#123;<br>    ckass <span class="hljs-keyword">Inner</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>    3.匿名内部类无类名<br>    4.访问外部类成员： 外部类名.this.成员<br>    5.外部类访问内部类需先创建对象<br>    6.不可用修饰符，可final，本质局部变量<br>    7.匿名类<br>        1.语法<br>        <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span> <span class="hljs-type"></span>类/接口(参数列表)&#123;<br>    类体<br>&#125;;<br></code></pre></td></tr></table></figure><br>        2.注意<br>        仅可使用一次；外部其他类不能访问；外部类与匿名类重名且匿名类访问时，遵循就近原则，访问外部类同上<br>    8.静态内部类<br>        可访问外部类所有静态成员，包含私有，无法访问非静态成员；可以任意添加访问修饰符；作用整个类；同上有就近原则<br>34.枚举<br>    1.实现：自定义类/使用enum关键字<br>    2.注意<br>    通常只读；使用final+static；可有多个属性<br>    3.enum<br>    使用关键字 enum 替代 class；直接使用 常量名(实参列表)；有多个常量，使用逗号隔开；将定义的常量对象写在前面；使用无参构造器创建常量对象可省略括号<br>    当我们使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类, 而且是一个 final 类；如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略；传统的 public static final Season2 SPRING = new Season2(“春天”, “温暖”); 简化成 SPRING(“春天”, “温暖”)， 这里必须知道，它调用的是哪个构造器；有多个枚举对象时，使用,间隔，最后有一个分号结尾；枚举对象必须放在枚举类的行首<br>    可使用Enum类相关方法<br>    接口： enum 类名 implements 接口 1，接口 2{}<br>35.注解<br>    不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息<br>    在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角色，例如用来配置应用程序的任何切面</p>
<pre><code class="hljs">基本注解（Annotation）
    @Override: 限定某个方法，是重写父类方法, 该注解只能用于方法
    @Deprecated: 用于表示某个程序元素(类, 方法等)已过时
    @SuppressWarnings: 抑制编译器警告
</code></pre>
<p>36.常用类<br>    1.包装类<br>        针对8种基本数据类型（boolean-&gt;Boolean char-&gt;Character byte-&gt;Byte short-&gt;Short int-&gt;Integer long-&gt;Long float-&gt;Float double-&gt;Double）<br>    2.包装类与基本数据类型转换<br>        1.jdk5前手动，形式： 装箱：基本类型-&gt;包装类型<br>        2.自动装箱底层调用valueOf方法，如Integer.valueOf()<br>    3.Integer类常用方法<br>        Integer.MIN_VALUE  返回最小值<br>        Integer.MAX_VALUE  返回最大值<br>    4.Character类常用方法<br>        Character.isDigit()  判断是不是数字<br>        Character.isLetter()  判断字母<br>        Character.isUpperCase()  判断大写<br>        Character.isLowerCase()  判断小写<br>        Character.isWhitespace()  判断空格<br>        Character.toUpperCase()  转换大写<br>        Character.toLowerCase()  转换小写<br>    5.String类<br>        1.保存字符串/一组字符序列<br>        2.字符串常量对象用双引号包括<br>        3.用Unicode编码，1字符占2字节<br>        4.常用构造：<br>            new String();<br>            new String(String original);<br>            new String(char[] a);<br>            new String(char[] a,int startIndex,int count);<br>            …<br>        5.final 不可继承<br>        6.有属性 private final char value[] 用于存放字符串内容 字符串不可变，一旦对象被分配，其内容不可变<br>        7.实现接口 Serializable（String可串行化，可网络传输） Comparable（String对象可比较大小）<br>        8.创建方式<br>            1.直接赋值<br>            如：String s = “hsp”;<br>            先从常量值查看是否有”hsp”数据空间，有则直接指向；没有则重新创建再指向；s最终指向常量池的空间地址<br>            2.调用构造器<br>            如：String s = new String(“hsp”);<br>            先在堆中创建空间，内维护value属性，指向常量池hsp空间；若没有hsp，重新创建；有，则直接通过value指向<br>        9.常用方法<br>            equals() 区分大小写判断内容是否相等<br>            equalslgnoreCase() 忽略大小写，同上<br>            length() 字符串长度<br>            indexOf() 获取字符在字符串中第1次出现的索引，从0开始，没有则返回-1<br>            lastIndexOf() 最后1次出现的索引，余同上<br>            substring() 截取指定范围的子串<br>            trim() 去前后空格<br>            charAt() 获取某索引处空格，不能用<code>Str[index]</code>形式<br>            replace() 替换字符串中字符<br>            split() 分割字符串，某些需转义<br>            compareTo() 比较字符串大小<br>            toCharArray() 转换为字符数组<br>            format() 格式字符串<br>    6.StringBuffer类<br>        1.很多方法同String，但其可变长度，是个容器<br>        2.直接父类 是 AbstractStringBuilde<br>        3.实现了 Serializable, 即 StringBuffer 的对象可以串行化<br>        4.在父类中 AbstractStringBuilder 有属性 char[] value,不是 final<br>        5.final类<br>        6.保存字符串变量，可更改，更新不用更改地址，效率较高<br>        7.互换<br>            1.String-&gt;StringBuffer<br>            <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">String str <span class="hljs-operator">=</span> <span class="hljs-string">&quot;111&quot;</span><span class="hljs-comment">;</span><br>StringBuffer stringBuffer <span class="hljs-operator">=</span> new StringBuffer(str)<span class="hljs-comment">;//法一，返回的才是 StringBuffer 对象，对 str 本身没有影响</span><br><br>StringBuffer stringBuffer1 <span class="hljs-operator">=</span> new StringBuffer()<span class="hljs-comment">;</span><br><span class="hljs-attribute">stringBuffer1</span> <span class="hljs-operator">=</span> stringBuffer1.append(str)<span class="hljs-comment">;//法二</span><br></code></pre></td></tr></table></figure><br>            2.StringBuffer-&gt;String<br>            <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">StringBuffer</span> stringBuffer3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuffer</span>(<span class="hljs-string">&quot;111&quot;</span>);<br><br><span class="hljs-built_in">String</span> s = stringBuffer3.toString();<span class="hljs-comment">//法一</span><br><span class="hljs-built_in">String</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(stringBuffer3);<span class="hljs-comment">//法二</span><br></code></pre></td></tr></table></figure><br>        8.常用方法<br>            append()  增<br>            delete()  删<br>            replace()  改<br>            insert() 插入<br>            indexOf()  同前<br>            length()  同前<br>    7.StringBuilder类：简易的StringBuffer类替换<br>    8.Math类<br>        常用方法<br>        abs() 绝对值<br>        pow() 求幂<br>        ceil() 向上取整，返回&gt;=该参数的最小整数（转成 double）<br>        floor() 向下取整，返回&lt;=该参数的最大整数（转成 double）<br>        round()  四舍五入<br>        sqrt()  开方<br>        random()  随机数<br>        min() 最小<br>        max() 最大<br>    9.Array类<br>        常用方法<br>        toString() 返回字符串形式<br>        sort() 排序（自然和定制）<br>        binary() 二分法搜索，但需先排序<br>        copyOf() 复制元素<br>        fill() 元素填充<br>        equals() 比较数组内容是否一致<br>        asList() 将一组值转换为list<br>    10.System类<br>        常用方法<br>        exit() 退出当前程序<br>        arraycopy() 复制数组元素<br>        currentTimeMillens() 返回时间：距离1970-1-1毫秒数<br>        gc() 垃圾回收机制<br>    11.BigInterger和BigDecimal<br>        1.区别<br>            BigInterger 适合保存较大整型<br>            BigDecimal 适合保存精度更高的浮点型<br>        2.常用方法<br>            add() 加<br>            subtract() 减<br>            multiply() 乘<br>            divide() 除<br>            在对 BigInteger 进行加减乘除的时候，需要使用对应的方法<br>    12.日期类<br>        1.第一代<br>            精确到毫秒<br>            SimpleDateFormat对象 格式和解析日期的类<br>            Date d1 = new Date(); //获取当前系统时间<br>            Date d2 = new Date(1111); //通过指定毫秒数得到时间<br>            可以把一个格式化的 String 转成对应的 Date；得到 Date 仍然在输出时，还是按照国外的形式，如果希望指定格式输出，需要转换；在把 String -&gt; Date，使用的 sdf 格式需要和你给的 String 的格式一样，否则会抛出转换异常<br>        2.第二代<br>            主要为Calendar类<br>            Calendar 是一个抽象类，并且构造器是 private；可以通过 getInstance() 来获取实例；没有提供对应的格式化的类；如果需要按照24小时进制来获取时间， Calendar.HOUR ==改成=&gt; Calendar.HOUR_OF_DA；返回月时候，是按照 0 开始编号<br>        3.第三代<br>            使用 now() 返回表示当前日期时间的 对象<br>            使用 DateTimeFormatter 对象来进行格式化<br>            提供 plus 和 minus 方法可以对当前时间进行加或者减<br>        4.DateTimeFormatter 格式日期类：类似SimpleDateFormat<br>        5.Instant 时间戳<br>            静态方法 now() 获取表示当前时间戳的对象<br>            通过 from 可以把 Instant 转成 Date<br>            通过 date 的 toInstant() 可以把 date 转成 Instant 对象<br>        6.其他日期类…<br>37.集合<br>    1.Collection 接口和常用方法<br>        add() 添加单个元素<br>        remove() 删除指定元素<br>        size() 查找元素是否存在<br>        contains() 获取元素个数<br>        isEmpty() 判断是否为空<br>        clear() 清空<br>        addAll() 添加多个元素<br>        containsAll() 查找多个元素是否存在<br>        removeAll() 删除多个元素<br>    2.Iterator（迭代器）<br>        主要用于遍历Collection集合中的元素，不存放对象<br>        所有实现Collection接口的集合类都有一个Iterator()方法，用以返回一个实现Iterator接口的对象<br>        使用例:<br>        <img src="/2023/09/10/java0to1/diedaiqi.png" srcset="/img/loading.gif" lazyload class=""><br>    3.List接口<br>        是Collection子接口<br>        1. List 集合类中元素有序(即添加顺序和取出顺序一致)、且可重复<br>        2. List 集合中的每个元素都有其对应的顺序索引，即支持索引；索引是从 0 开始<br>        3.常用方法<br>            add() 在指定位置插入元素<br>            addAll() 从指定位置开始添加所有元素<br>            get() 获取指定位置元素<br>            indexOf() 返回在集合初次出现的位置<br>            lastIndexOf() 返回在当前集合中末次出现的位置<br>            remove() 移除指定位置的元素，并返回此元素<br>            set(int index, Object ele) 设置指定 index 位置的元素为 ele , 相当于是替换<br>    4.ArrayList<br>        1.基本等同于Vector<br>        2.由数组实现存储<br>        …<br>    5.Vector<br>        1.是个对象数组<br>        2.Vector 和 ArrayList 的比较<br>            <img src="/2023/09/10/java0to1/vector.png" srcset="/img/loading.gif" lazyload class=""><br>    6.LinkedList<br>        <img src="/2023/09/10/java0to1/linklist.png" srcset="/img/loading.gif" lazyload class=""><br>    7.Set接口<br>        1.Collection子接口<br>        2.set 接口的实现类的对象（Set 接口对象）, 不能存放重复的元素, 可以添加一个 null<br>        3. set 接口对象存放数据是无序（即添加的顺序和取出的顺序不一致）<br>    8.Set 接口实现类-HashSet<br>        <img src="/2023/09/10/java0to1/hashmap.png" srcset="/img/loading.gif" lazyload class=""><br>    9.Set 接口实现类-LinkedHashSet<br>        <img src="/2023/09/10/java0to1/linkset1.png" srcset="/img/loading.gif" lazyload class=""><br>    10.Map<br>        1. Map 与 Collection 并列存在。用于保存具有映射关系的数据:Key-Value(双列元素)<br>        2. Map 中的 key 和 value 可以是任何引用类型的数据，会封装到 HashMap$Node 对象中<br>        3. Map 中的 key 不允许重复，原因和 HashSet 一样，前面分析过源码.<br>        4. Map 中的 value 可以重复<br>        5. Map 的 key 可以为 null, value 也可以为 null ，注意 key 为 null，只能有一个，value 为 null ,可以多个<br>        6. 常用 String 类作为 Map 的 key<br>        7. key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到对应的 value<br>        8.常用方法<br>            put() 添加k-v<br>            remove() 根据键删除映射关系<br>            get() 根据键获取值<br>            size() 获取元素个数<br>            isEmpty() 判断个数是否为 0<br>            clear() 清除 key-value<br>            containsKey() 查找键是否存在<br>        9.接口实现<br>            HasMmap<br>            <img src="/2023/09/10/java0to1/hashmap1.png" srcset="/img/loading.gif" lazyload class=""><br>            HashTable<br>            <img src="/2023/09/10/java0to1/hashtable.png" srcset="/img/loading.gif" lazyload class=""><br>            Properties<br>            <img src="/2023/09/10/java0to1/properties.png" srcset="/img/loading.gif" lazyload class=""><br>    11.小结<br>        <img src="/2023/09/10/java0to1/littletotal.png" srcset="/img/loading.gif" lazyload class=""><br>38.线程<br>    1.创建线程两种方式：1.继承Thread类，重写run方法 2.实现Runnable接口，重写run方法<br>    2.start0() 是本地方法，是 JVM 调用，底层是 c/c++实现，真正实现多线程的效果， 是 start0(), 而不是 run<br>    3.当 main 线程启动一个子线程 Thread-0，主线程不会阻塞，会继续执行，这时，主线程和子线程是交替执行<br>    4.Thread类<br>        1.当一个类继承了 Thread 类， 该类就可以当做线程使用<br>        2.我们会重写 run 方法，写上自己的业务代码<br>        3.run Thread 类 实现了 Runnable 接口的run方法<br>    5.Runnable接口：本质与上无区别，更适合多线程共享一个资源，避免单继承限制<br>    6.线程终止<br>        <img src="/2023/09/10/java0to1/xianchengzhongzhi.png" srcset="/img/loading.gif" lazyload class=""><br>    7.常用方法<br>    <img src="/2023/09/10/java0to1/xianchengchangyongfangfa1.png" srcset="/img/loading.gif" lazyload class=""><br>    <img src="/2023/09/10/java0to1/xianchengchangyongfangfa2.png" srcset="/img/loading.gif" lazyload class=""><br>    8.用户线程&amp;守护线程<br>        <img src="/2023/09/10/java0to1/userxiancheng.png" srcset="/img/loading.gif" lazyload class=""><br>        没有进行设置即使main线程执行完毕守护线程也不退出<br>    9.线程的生命周期<br>        <img src="/2023/09/10/java0to1/xianchengalive.png" srcset="/img/loading.gif" lazyload class=""><br>    10.线程状态转换<br>        <img src="/2023/09/10/java0to1/xianchengalive2.png" srcset="/img/loading.gif" lazyload class=""><br>    11.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/09/14/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="2023/09/14：java反序列化入门记录">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">2023/09/14：java反序列化入门记录</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/09/09/morexss/" title="2023/09/09：canvas，png和xss">
                        <span class="hidden-mobile">2023/09/09：canvas，png和xss</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
